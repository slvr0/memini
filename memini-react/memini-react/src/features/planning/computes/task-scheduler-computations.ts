
import moment, { weekdays } from "moment";
import {ITask, IDisplayTask} from '../../../features/tasks/interfaces/task-interface'
import { StatusType, TaskStatus } from "../../../mui-wrappers/mui-status-circle-wrapper";
import _ from 'lodash';
import { ICalendarDate } from "../../../interfaces/common-interfaces";    

/*Calculates the Task status on an ITask relative to the current time, returns the color profile map (maps to the palette) as status is presented with a colored circle. */
export const calculateTaskStatus = (task: ITask, timeNow: moment.Moment =  moment()) : StatusType  => { 

    var taskAsMoment: moment.Moment = moment({
        year: task.Year,
        month: task.Month,
        day: task.Day,
        hour: Math.floor(task.StartTime / 100), 
        minute: task.StartTime % 100
    });

    if(taskAsMoment.isBefore(timeNow))
        return TaskStatus.PASSED;

    if(taskAsMoment.isSame(timeNow, 'day'))
        return TaskStatus.UPCOMING;

    return TaskStatus.FUTURE; 
}

/* Generated by Claude sonnet 4.1 2025-09-25, generally works but cannot estimate index spans. Tried prompting it, no success. */
export const calculateTaskDisplayMetricsSimple = (tasks: Array<ITask>, pixelsPerHour: number): Array<IDisplayTask> => {
    if (!tasks.length) return [];

    const sortedTasks = _.sortBy(tasks, 'StartTime');

    const result = sortedTasks.reduce<IDisplayTask[]>((acc, currentTask, index) => { 
        const previousOverlapping = acc.filter(prevTask => 
            prevTask.EndTime > currentTask.StartTime
        );
        
        const usedSlots = new Set(previousOverlapping.map(task => task.slotIndex));
        let slotIndex = 0;
        while (usedSlots.has(slotIndex)) slotIndex++;
        
        acc.push({
            UserTaskKey: currentTask.UserTaskKey,            
            Title: currentTask.Title,
            Description: currentTask.Description,
            StartTime: currentTask.StartTime,
            EndTime: currentTask.EndTime,
            Year: currentTask.Year,
            Month: currentTask.Month,
            Day: currentTask.Day,
            status: calculateTaskStatus(currentTask),
            yPosition: (currentTask.StartTime / 60) * pixelsPerHour,
            height: ((currentTask.EndTime - currentTask.StartTime) / 60) * pixelsPerHour,
            slotIndex,
            slotCount: 1 // Will be updated in second pass
        });
        
        return acc;
    }, []);
  
    result.forEach((currentTask, index) => {
        const overlappingTasks = result.filter(otherTask =>
            currentTask.StartTime < otherTask.EndTime && currentTask.EndTime > otherTask.StartTime
        );        

        const usedSlotIndices = overlappingTasks.map(task => task.slotIndex);
        const slotCount = Math.max(...usedSlotIndices) + 1;      
        currentTask.slotCount = slotCount;

    });
    
    return result;
};

//gets the weekdays of a selected week 
export const getWeekDates = (year: number, weekNum: number): ICalendarDate[] => {
  const startOfYear = new Date(year, 0, 1);
  const startOfWeek = new Date(startOfYear.getTime() + (weekNum - 1) * 7 * 24 * 60 * 60 * 1000);
  
  // Adjust to Monday as start of week
  const dayOfWeek = startOfWeek.getDay();
  const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
  const monday = new Date(startOfWeek.getTime() + mondayOffset * 24 * 60 * 60 * 1000);
  
  const weekDates: ICalendarDate[] = [];
  
  // Generate 7 days starting from Monday
  for (let i = 0; i < 7; i++) {
    const currentDate = new Date(monday.getTime() + i * 24 * 60 * 60 * 1000);
    
    weekDates.push({
      year: currentDate.getFullYear(),
      month: currentDate.getMonth(), // 0-based
      day: currentDate.getDate(),
      week: weekNum,
      weekDay: currentDate.getDay() // 0 = Sunday, 1 = Monday, etc.      
    });
  }
  
  return weekDates;
};

export const calculateTaskPixelTime = (pixel:number, maxPixel:number) : number => Math.round( pixel * 24 * 60 / maxPixel ) ;







