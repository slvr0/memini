
import moment, { weekdays } from "moment";
import {ITask, IDisplayTask, IStoredUserTask} from '../../../features/tasks/interfaces/task-interface'
import { StatusType, TaskStatus } from "../../../mui-wrappers/mui-status-circle-wrapper";
import _ from 'lodash';
import { ICalendarDate, ISimpleDate } from "../../../interfaces/common-interfaces";    
import { ICoreNode } from "@/features/tasks/interfaces/core-node-interface";

import dayjs from "dayjs";
import utc from 'dayjs/plugin/utc';
import timezone from 'dayjs/plugin/timezone';
dayjs.extend(utc);
dayjs.extend(timezone);

/* Generated by Claude sonnet 4.1 2025-09-25, generally works but cannot estimate index spans. Tried prompting it, no success. */
export const calculateTaskDisplayMetricsSimple = (tasks: Array<ITask>, pixelsPerHour: number): Array<IDisplayTask> => {
    if (!tasks.length) return [];

    const sortedTasks = _.sortBy(tasks, 'StartTime');

    const result = sortedTasks.reduce<IDisplayTask[]>((acc, currentTask, index) => { 
        const previousOverlapping = acc.filter(prevTask => 
            prevTask.EndTime > currentTask.StartTime
        );
        
        const usedSlots = new Set(previousOverlapping.map(task => task.slotIndex));
        let slotIndex = 0;
        while (usedSlots.has(slotIndex)) slotIndex++;
        
        acc.push({
            UserTaskKey: currentTask.UserTaskKey,            
            Title: currentTask.Title,
            Description: currentTask.Description,
            StartTime: currentTask.StartTime,
            EndTime: currentTask.EndTime,
            Year: currentTask.Year,
            Month: currentTask.Month,
            Day: currentTask.Day,
            yPosition: (currentTask.StartTime / 60) * pixelsPerHour,
            height: ((currentTask.EndTime - currentTask.StartTime) / 60) * pixelsPerHour,
            slotIndex,
            slotCount: 1 // Will be updated in second pass
        });
        
        return acc;
    }, []);
  
    result.forEach((currentTask, index) => {
        const overlappingTasks = result.filter(otherTask =>
            currentTask.StartTime < otherTask.EndTime && currentTask.EndTime > otherTask.StartTime
        );        

        const usedSlotIndices = overlappingTasks.map(task => task.slotIndex);
        const slotCount = Math.max(...usedSlotIndices) + 1;      
        currentTask.slotCount = slotCount;

    });
    
    return result;
};

//gets the weekdays of a selected week 
export const getWeekDates = (year: number, weekNum: number): ICalendarDate[] => {
  const startOfYear = new Date(year, 0, 1);
  const startOfWeek = new Date(startOfYear.getTime() + (weekNum - 1) * 7 * 24 * 60 * 60 * 1000);
  
  // Adjust to Monday as start of week
  const dayOfWeek = startOfWeek.getDay();
  const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
  const monday = new Date(startOfWeek.getTime() + mondayOffset * 24 * 60 * 60 * 1000);
  
  const weekDates: ICalendarDate[] = [];
  
  // Generate 7 days starting from Monday
  for (let i = 0; i < 7; i++) {
    const currentDate = new Date(monday.getTime() + i * 24 * 60 * 60 * 1000);
    
    weekDates.push({
      year: currentDate.getFullYear(),
      month: currentDate.getMonth(), // 0-based
      day: currentDate.getDate(),
      week: weekNum,
      weekDay: currentDate.getDay() // 0 = Sunday, 1 = Monday, etc.      
    });
  }
  
  return weekDates;
};

// export const dayJsToCalendarDate = (date: dayjs.Dayjs) : ICalendarDate => {
//     const dateParts = date.split('-'); // Assuming format is "YYYY-MM-DD"
//     return {

export const calculateTaskPixelTime = (pixel:number, maxPixel:number) : number => Math.round( pixel * 24 * 60 / maxPixel ) ;

export const groupTasksByDay = (tasks: IStoredUserTask[]) => {
    return tasks.reduce((acc, task) => {
        if (!task.Created) return acc;
        
        const date = new Date(task.Created);
        
        // Check if date is valid
        if (isNaN(date.getTime()))        
            return acc;       
        
        const dayKey = date.toISOString().split('T')[0]; // "2025-03-05"
        
        if (!acc[dayKey]) {
            acc[dayKey] = [];
        }
        acc[dayKey].push(task);
        
        return acc;
    }, {} as Record<string, IStoredUserTask[]>);
};

/**
 * Convert dayjs to ISimpleDate
 */
export function toSimpleDate(date: dayjs.Dayjs): ISimpleDate {
    return {
        year: date.year(),
        month: date.month(), 
        day: date.date()
    };
}


/**
 * Convert ISimpleDate back to dayjs
 */
export function fromSimpleDateToDayJs(calDate: ISimpleDate): dayjs.Dayjs {
    return dayjs()
        .year(calDate.year)
        .month(calDate.month)
        .date(calDate.day)
        .startOf('day');
}

/**
 * Get minutes since midnight (00:00)
 */
export function toMinutes(date: dayjs.Dayjs): number {
    const hours = date.hour();
    const minutes = date.minute();
    return hours * 60 + minutes;
}

/**
 * Create dayjs from minutes since midnight
 */
export function minutesToDayJs(
    minutes: number,
    baseDate?: dayjs.Dayjs
): dayjs.Dayjs {
    const base = baseDate || dayjs().startOf('day');
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return base.hour(hours).minute(mins).second(0).millisecond(0);
}





