
import moment, { weekdays } from "moment";

import { StatusType, TaskStatus } from "../../../mui-wrappers/mui-status-circle-wrapper";
import _ from 'lodash';
import { ICalendarDate, ISimpleDate } from "../../../interfaces/common-interfaces";    
import { ICoreNode } from "@/interfaces/core-node-interface";

import dayjs from "dayjs";
import utc from 'dayjs/plugin/utc';
import timezone from 'dayjs/plugin/timezone';
import { Activity, IDisplayActivity } from "@/features/activity/interface/activity";
dayjs.extend(utc);
dayjs.extend(timezone);

/* Generated by Claude sonnet 4.1 2025-09-25, generally works but cannot estimate index spans. Tried prompting it, no success. */

export const calculateActivityDisplayMetrics = (activities: Array<Activity>, pixelsPerHour: number) : Array<IDisplayActivity> => {
    if (!activities.length) return [];

    // Sort by start time
    const sortedActivities = _.sortBy(activities, activity => activity.StartTime);

    const result = sortedActivities.reduce<IDisplayActivity[]>((acc, currentActivity) => {
        const currentStartTime = currentActivity.StartTime;
        const currentEndTime = currentActivity.EndTime;
        
        // Find overlapping activities that are already placed
        const previousOverlapping = acc.filter(prevActivity => {
            const prevEndTime = prevActivity.EndDate.hour() * 60 + prevActivity.EndDate.minute();
            return prevEndTime > currentStartTime;
        });
        
        // Find available slot index
        const usedSlots = new Set(previousOverlapping.map(activity => activity.slotIndex));
        let slotIndex = 0;
        while (usedSlots.has(slotIndex)) slotIndex++;
        
        acc.push({           
            OwnerUserkey: currentActivity.OwnerUserkey,
            Source: currentActivity.Source,
            Guid: currentActivity.Guid,
            Label: currentActivity.Label,
            Description: currentActivity.Description,
            StartDate: currentActivity.StartDate,
            EndDate: currentActivity.EndDate,
            DateAdded: currentActivity.Created,
            Country: currentActivity.Country,
            CountryCode: currentActivity.CountryCode,
            City: currentActivity.City,
            Type: currentActivity.Type,
            ContentInfo: currentActivity.ContentInfo,
            ContentMedia: currentActivity.ContentMedia,
            SpatialInfo: currentActivity.SpatialInfo,
            PoiInfo: currentActivity.PoiInfo,
            CommercialInfo: currentActivity.CommercialStatusInfo,
            
            // Display metrics
            yPosition: (currentStartTime / 60) * pixelsPerHour,
            height: ((currentEndTime - currentStartTime) / 60) * pixelsPerHour,
            slotIndex,
            slotCount: 1 // Will be updated in second pass
        } as any);
        
        return acc;
    }, []);
    
    // Second pass: update slot counts based on overlaps
    result.forEach((currentActivity) => {
        const currentStartTime = currentActivity.StartDate.hour() * 60 + currentActivity.StartDate.minute();
        const currentEndTime = currentActivity.EndDate.hour() * 60 + currentActivity.EndDate.minute();
        
        const overlappingActivities = result.filter(otherActivity => {
            const otherStartTime = otherActivity.StartDate.hour() * 60 + otherActivity.StartDate.minute();
            const otherEndTime = otherActivity.EndDate.hour() * 60 + otherActivity.EndDate.minute();
            return currentStartTime < otherEndTime && currentEndTime > otherStartTime;
        });
        
        const usedSlotIndices = overlappingActivities.map(activity => activity.slotIndex);
        const slotCount = Math.max(...usedSlotIndices) + 1;
        currentActivity.slotCount = slotCount;
    });
    
    return result;
}

//gets the weekdays of a selected week 
export const getWeekDates = (year: number, weekNum: number): ICalendarDate[] => {
  const startOfYear = new Date(year, 0, 1);
  const startOfWeek = new Date(startOfYear.getTime() + (weekNum - 1) * 7 * 24 * 60 * 60 * 1000);
  
  // Adjust to Monday as start of week
  const dayOfWeek = startOfWeek.getDay();
  const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
  const monday = new Date(startOfWeek.getTime() + mondayOffset * 24 * 60 * 60 * 1000);
  
  const weekDates: ICalendarDate[] = [];
  
  // Generate 7 days starting from Monday
  for (let i = 0; i < 7; i++) {
    const currentDate = new Date(monday.getTime() + i * 24 * 60 * 60 * 1000);
    
    weekDates.push({
      year: currentDate.getFullYear(),
      month: currentDate.getMonth(), // 0-based
      day: currentDate.getDate(),
      week: weekNum,
      weekDay: currentDate.getDay() // 0 = Sunday, 1 = Monday, etc.      
    });
  }
  
  return weekDates;
};

// export const dayJsToCalendarDate = (date: dayjs.Dayjs) : ICalendarDate => {
//     const dateParts = date.split('-'); // Assuming format is "YYYY-MM-DD"
//     return {

export const calculateTaskPixelTime = (pixel:number, maxPixel:number) : number => Math.round( pixel * 24 * 60 / maxPixel ) ;

export const groupNodesByDay = (activities: Activity[]) => {
    return activities.reduce((acc, activity) => {
        if (!activity.Created) return acc;        
 
        if (!activity.Created.isValid()) {
            return acc;
        }
        
        const dayKey = activity.Created.format('YYYY-MM-DD'); // "2025-03-05"
        
        if (!acc[dayKey]) {
            acc[dayKey] = [];
        }
        acc[dayKey].push(activity);
        
        return acc;
    }, {} as Record<string, any[]>);
};

/**
 * Convert dayjs to ISimpleDate
 */
export function toSimpleDate(date: dayjs.Dayjs): ISimpleDate {
    return {
        year: date.year(),
        month: date.month(), 
        day: date.date()
    };
}


/**
 * Convert ISimpleDate back to dayjs
 */
export function fromSimpleDateToDayJs(calDate: ISimpleDate): dayjs.Dayjs {
    return dayjs()
        .year(calDate.year)
        .month(calDate.month)
        .date(calDate.day)
        .startOf('day');
}

/**
 * Get minutes since midnight (00:00)
 */
export function toMinutes(date: dayjs.Dayjs): number {
    const hours = date.hour();
    const minutes = date.minute();
    return hours * 60 + minutes;
}

/**
 * Create dayjs from minutes since midnight
 */
export function minutesToDayJs(
    minutes: number,
    baseDate?: dayjs.Dayjs
): dayjs.Dayjs {
    const base = baseDate || dayjs().startOf('day');
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return base.hour(hours).minute(mins).second(0).millisecond(0);
}





