
import { HourglassEmpty } from '@mui/icons-material';
import moment from "moment";
import {ITask, IDisplayTask} from '../../../features/tasks/interfaces/task-interface'
import { StatusColorProfileMap, StatusType, TaskStatus } from "../../../mui-wrappers/mui-status-circle-wrapper";
import _ from 'lodash';
import { sortBy, chain, flatMap } from 'lodash';
    
/*Calculates the Task status on an ITask relative to the current time, returns the color profile map (maps to the palette) as status is presented with a colored circle. */
export const calculateTaskStatus = (task: ITask, timeNow: moment.Moment =  moment()) : StatusType  => { 

    var taskAsMoment: moment.Moment = moment({
        year: task.Year,
        month: task.Month,
        day: task.Day,
        hour: Math.floor(task.StartTime / 100), 
        minute: task.StartTime % 100
    });

    if(taskAsMoment.isBefore(timeNow))
        return TaskStatus.PASSED;

    if(taskAsMoment.isSame(timeNow, 'day'))
        return TaskStatus.UPCOMING;

    return TaskStatus.FUTURE; 
}

/* Generated by Claude sonnet 4.1 2025-09-25, generally works but cannot estimate index spans. Tried prompting it, no success. */
export const calculateTaskDisplayMetricsSimple = (tasks: Array<ITask>, pixelsPerHour: number): Array<IDisplayTask> => {
    if (!tasks.length) return [];

    const sortedTasks = _.sortBy(tasks, 'StartTime');

    const result = sortedTasks.reduce<IDisplayTask[]>((acc, currentTask, index) => { 
        const previousOverlapping = acc.filter(prevTask => 
            prevTask.EndTime > currentTask.StartTime
        );
        
        const usedSlots = new Set(previousOverlapping.map(task => task.slotIndex));
        let slotIndex = 0;
        while (usedSlots.has(slotIndex)) slotIndex++;
        
        acc.push({
            UserTaskKey: currentTask.UserTaskKey,
            Title: currentTask.Title,
            Description: currentTask.Description,
            StartTime: currentTask.StartTime,
            EndTime: currentTask.EndTime,
            status: calculateTaskStatus(currentTask),
            yPosition: (currentTask.StartTime / 60) * pixelsPerHour,
            height: ((currentTask.EndTime - currentTask.StartTime) / 60) * pixelsPerHour,
            slotIndex,
            slotCount: 1 // Will be updated in second pass
        });
        
        return acc;
    }, []);
  
    result.forEach((currentTask, index) => {
        const overlappingTasks = result.filter(otherTask =>
            currentTask.StartTime < otherTask.EndTime && currentTask.EndTime > otherTask.StartTime
        );        

        const usedSlotIndices = overlappingTasks.map(task => task.slotIndex);
        const slotCount = Math.max(...usedSlotIndices) + 1;      
        currentTask.slotCount = slotCount;

    });
    
    return result;
};
